datasource db {
    provider  = "postgresql"
    url       = env("DATABASE_URL")
    directUrl = env("DIRECT_URL")
}

generator client {
    provider = "prisma-client-js"
    output   = "./generated/client"
}

generator zod {
    provider = "prisma-zod-generator"
    output   = "./zod"
    config   = "./zod-generator.config.json"
}

model User {
    id                 String              @id @default(cuid())
    name               String
    email              String
    emailVerified      Boolean
    image              String?
    createdAt          DateTime
    updatedAt          DateTime
    username           String?
    role               String?
    banned             Boolean?
    banReason          String?
    banExpires         DateTime?
    onboardingComplete Boolean             @default(false)
    paymentsCustomerId String?
    locale             String?
    twoFactorEnabled   Boolean?
    sessions           Session[]
    accounts           Account[]
    passkeys           Passkey[]
    invitations        Invitation[]
    purchases          Purchase[]
    members            Member[]
    twofactors         TwoFactor[]
    aiChats            AiChat[]
    
    // Document system relations
    createdFolders     Folder[]            @relation("FolderCreator")
    createdDocuments   Document[]          @relation("DocumentCreator")
    editedDocuments    Document[]          @relation("DocumentLastEditor")
    documentVersions   DocumentVersion[]   @relation("DocumentVersionCreator")
    documentComments   DocumentComment[]   @relation("DocumentCommentAuthor")
    documentShares     DocumentShare[]     @relation("DocumentShareUser")
    createdSources     Source[]            @relation("SourceCreator")

    @@unique([email])
    @@unique([username])
    @@map("user")
}

model Session {
    id        String   @id @default(cuid())
    expiresAt DateTime
    ipAddress String?
    userAgent String?
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    impersonatedBy String?

    activeOrganizationId String?

    token     String
    createdAt DateTime
    updatedAt DateTime

    @@unique([token])
    @@map("session")
}

model Account {
    id           String    @id @default(cuid())
    accountId    String
    providerId   String
    userId       String
    user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    accessToken  String?   @db.Text
    refreshToken String?   @db.Text
    idToken      String?   @db.Text
    expiresAt    DateTime?
    password     String?

    accessTokenExpiresAt  DateTime?
    refreshTokenExpiresAt DateTime?
    scope                 String?
    createdAt             DateTime
    updatedAt             DateTime

    @@map("account")
}

model Verification {
    id         String   @id @default(cuid())
    identifier String
    value      String   @db.Text
    expiresAt  DateTime

    createdAt DateTime?
    updatedAt DateTime?

    @@map("verification")
}

model Passkey {
    id           String    @id @default(cuid())
    name         String?
    publicKey    String
    userId       String
    user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    credentialID String
    counter      Int
    deviceType   String
    backedUp     Boolean
    transports   String?
    createdAt    DateTime?

    @@map("passkey")
}

model TwoFactor {
    id          String @id @default(cuid())
    secret      String
    backupCodes String
    userId      String
    user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("twoFactor")
}

model Organization {
    id                 String       @id @default(cuid())
    name               String
    slug               String?
    logo               String?
    createdAt          DateTime
    metadata           String?
    paymentsCustomerId String?
    members            Member[]
    invitations        Invitation[]
    purchases          Purchase[]
    aiChats            AiChat[]
    
    // Document system relations
    folders            Folder[]
    documents          Document[]
    sources            Source[]

    @@unique([slug])
    @@map("organization")
}

model Member {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    userId         String
    user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
    role           String
    createdAt      DateTime

    @@unique([organizationId, userId])
    @@map("member")
}

model Invitation {
    id             String       @id @default(cuid())
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    email          String
    role           String?
    status         String
    expiresAt      DateTime
    inviterId      String
    user           User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)

    @@map("invitation")
}

enum PurchaseType {
    SUBSCRIPTION
    ONE_TIME
}

model Purchase {
    id             String        @id @default(cuid())
    organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    organizationId String?
    user           User?         @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId         String?
    type           PurchaseType
    customerId     String
    subscriptionId String?       @unique
    productId      String
    status         String?
    createdAt      DateTime      @default(now())
    updatedAt      DateTime      @updatedAt

    @@index([subscriptionId])
    @@map("purchase")
}

// Folders for organizing documents
model Folder {
    id               String       @id @default(cuid())
    name             String
    organizationId   String
    organization     Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    parentFolderId   String?
    parentFolder     Folder?      @relation("FolderHierarchy", fields: [parentFolderId], references: [id], onDelete: Cascade)
    subFolders       Folder[]     @relation("FolderHierarchy")
    documents        Document[]
    createdAt        DateTime     @default(now())
    updatedAt        DateTime     @updatedAt
    createdBy        String
    creator          User         @relation("FolderCreator", fields: [createdBy], references: [id])

    @@index([organizationId])
    @@index([parentFolderId])
    @@map("folder")
}

// Documents with Tiptap content
model Document {
    id               String            @id @default(cuid())
    title            String
    /// [TiptapContent]
    content          Json              @default("{}")
    organizationId   String
    organization     Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    folderId         String?
    folder           Folder?           @relation(fields: [folderId], references: [id], onDelete: SetNull)
    createdBy        String
    creator          User              @relation("DocumentCreator", fields: [createdBy], references: [id])
    lastEditedBy     String?
    lastEditor       User?             @relation("DocumentLastEditor", fields: [lastEditedBy], references: [id])
    
    // Document metadata
    slug             String?
    description      String?
    tags             String[]
    isTemplate       Boolean           @default(false)
    isPublic         Boolean           @default(false)
    
    // Content analysis (for AI context)
    wordCount        Int               @default(0)
    /// [ExtractedText] - Plain text for search/AI
    extractedText    String?           @db.Text
    
    // Collaboration
    versions         DocumentVersion[]
    comments         DocumentComment[]
    shares           DocumentShare[]
    
    // Relations to sources
    documentSources  DocumentSource[]
    
    // AI chats related to this document
    aiChats          AiChat[]
    
    createdAt        DateTime          @default(now())
    updatedAt        DateTime          @updatedAt

    @@unique([organizationId, slug])
    @@index([organizationId])
    @@index([folderId])
    @@index([createdBy])
    @@map("document")
}

// Document versions for history/snapshots
model DocumentVersion {
    id          String   @id @default(cuid())
    documentId  String
    document    Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
    /// [TiptapContent]
    content     Json
    version     Int
    createdBy   String
    creator     User     @relation("DocumentVersionCreator", fields: [createdBy], references: [id])
    createdAt   DateTime @default(now())
    
    @@index([documentId])
    @@map("document_version")
}

// Comments on documents (using Tiptap Pro comments)
model DocumentComment {
    id          String   @id @default(cuid())
    documentId  String
    document    Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
    /// [CommentPosition] - Tiptap position data
    position    Json
    content     String   @db.Text
    authorId    String
    author      User     @relation("DocumentCommentAuthor", fields: [authorId], references: [id])
    isResolved  Boolean  @default(false)
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    
    @@index([documentId])
    @@map("document_comment")
}

// Document sharing
model DocumentShare {
    id          String    @id @default(cuid())
    documentId  String
    document    Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
    userId      String?
    user        User?     @relation("DocumentShareUser", fields: [userId], references: [id], onDelete: Cascade)
    email       String?
    permission  String    // "view" | "comment" | "edit"
    token       String?   @unique
    expiresAt   DateTime?
    createdAt   DateTime  @default(now())
    
    @@index([documentId])
    @@index([token])
    @@map("document_share")
}

// Sources (files, images, URLs) for workspace knowledge
model Source {
    id               String           @id @default(cuid())
    name             String
    organizationId   String
    organization     Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    
    // Source content
    type             String           // "pdf" | "doc" | "docx" | "image" | "url"
    url              String?
    filePath         String?
    originalFileName String?
    
    // Extracted content for AI
    /// [ExtractedContent] - Text extracted from files
    extractedText    String?          @db.Text
    /// [SourceMetadata] - File size, dimensions, etc.
    metadata         Json             @default("{}")
    
    // Processing status
    processingStatus String           @default("pending") // "pending" | "processing" | "completed" | "failed"
    
    // Relations
    documentSources  DocumentSource[]
    
    createdBy        String
    creator          User             @relation("SourceCreator", fields: [createdBy], references: [id])
    createdAt        DateTime         @default(now())
    updatedAt        DateTime         @updatedAt

    @@index([organizationId])
    @@index([type])
    @@index([processingStatus])
    @@map("source")
}

// Many-to-many relationship between documents and sources
model DocumentSource {
    id         String   @id @default(cuid())
    documentId String
    document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
    sourceId   String
    source     Source   @relation(fields: [sourceId], references: [id], onDelete: Cascade)
    
    // Context of how source is used in document
    context    String?
    /// [SourceUsage] - Where/how source is referenced
    usage      Json?    @default("{}")
    
    createdAt  DateTime @default(now())

    @@unique([documentId, sourceId])
    @@index([documentId])
    @@index([sourceId])
    @@map("document_source")
}

// Enhanced AI Chat with document context
model AiChat {
    id               String        @id @default(cuid())
    organizationId   String?
    organization     Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    userId           String?
    user             User?         @relation(fields: [userId], references: [id], onDelete: Cascade)
    
    // Chat context
    documentId       String?
    document         Document?     @relation(fields: [documentId], references: [id], onDelete: SetNull)
    title            String?
    
    /// [ChatMessages] - Enhanced with document context
    messages         Json          @default("[]")
    
    // AI Context
    /// [WorkspaceContext] - Available documents, sources, etc.
    workspaceContext Json?         @default("{}")
    
    createdAt        DateTime      @default(now())
    updatedAt        DateTime      @updatedAt

    @@index([organizationId])
    @@index([documentId])
    @@map("ai_chat")
}

